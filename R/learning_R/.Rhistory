max(score)
min(score)
x <- factor(c('Male', 'Female', 'Male', 'Male', "Male"))
x
table(x) # Returns count of elem in each level
x <- c(4.258,-3.8432, 5.4456, 7.456, 9.5605)
abs(x)
ceiling(x) # Returns the next possible integer for each elem, in positive direction. So, for -3.8432, it will be 3
ln(x)
x <- c(4, 3, 6)
factorial(x) # for each elem
x <- rnorm(10)
x
x <-rnorm(10, mean = 20, sd=2)
x
x
A <- matrix(nrow = 2, ncol = 3)
A
dim(A) # gives dimension
# Can also be created with dim
m <- c(1, 2, 3, 4, 5, 6)
dim(m) <- c(2, 3) # Yes, here 2 and 3 are rows and columns
B <- matrix(c(1, 2, 3, 4, 5, 6)) # Created a 6 x 1 vector (1 rows because it is column-wise)
B
B <- matrix(c(1, 2, 3, 4, 5, 6), byrow = TRUE)
B
# With matrix and seq
m <- matrix(1:12, nrow = 2, ncol = 3)
m
# With matrix and seq
m <- matrix(1:12, nrow = 4, ncol = 3, byrow = TRUE)
m
# With matrix and seq
m <- matrix(1:12, nrow = 4, ncol = 3)
m
C <- matrix(c(1, 2, 3, 4, 5, 6), nrow = 2, ncol = 3, byrow = TRUE)
C
nrow(C) # Gives of
ncol(C)
length(C) # Number of elems in the matrix
# Initialize matrix dimensions
A <- matrix(4, nrow = 2, ncol = 3) # All slots will be filled with 4
A
# Matrix Diag function. diag(x, row, col)
m <- diag(1, 3, 3)
m
# Matrix Diag function. diag(x, row, col)
m <- diag(3, 3)
m
m <- diag(3, 4, 5)
m
m <- diag(1:3) # diagonal is 1 to 3 and the rests are 0. row and col are not needed. Figured from the range
m
m <- diag(1:5) # diagonal is 1 to 3 and the rests are 0. row and col are not needed. Figured from the seq range
m
# Giving names to rows and columns
m <- matrix(1:12, 4, 3, TRUE)
rownames(m) <- c('row1', 'row2', 'row3', 'row4')
colnames(m) <- c('col1', 'col2', 'col3')
m
rownames(m) <- c(1, 2, 3, 4)
colnames(m) <- c('A', 'B', 'C')
m
# Indexing matrices
A <- Matrix(1:10, 5, 2)
A
# Indexing matrices
A <- Matrix(1:10, 5, 2)
A
# Indexing matrices
A <- matrix(1:10, 5, 2)
A
A[1, 2] # [row, col]
A[1:nrow(A), 1:ncol(A)]
A[1, 2] = 9 # reassign
A = A[-nrow(A)] #Last col is deleted. Since negative is for exclusion, rows or cols can be deleted this way.
dim(A)
# Indexing matrices
A <- matrix(1:10, 5, 2)
A[1, 2] # [row, col]
A[1, ] # Entire first row
A[-1,] # All the rows excepts first one
A[, 2] # Entire 2nd col
A[nrow(A), ] # entire last row. Otherway with ncol() for the column
A[1:4, 1:2] # 4 rows and 2 columns
A[1:nrow(A), 1:ncol(A)] # Entire matrix
A[c(1, 3), ] # Entire first and third rows
A[1, 2] = 9 # reassign
A = A[-nrow(A)] #Last col is deleted. Since negative is for exclusion, rows or cols can be deleted this way.
dim(A)
A = A[-nrow(A), ] #Last col is deleted. Since negative is for exclusion, rows or cols can be deleted this way.
dim(A)
A[1, 2] = 9 # reassign
A = A[-nrow(A), ] #Last col is deleted. Since negative is for exclusion, rows or cols can be deleted this way.
dim(A)
A[1, 2] = 9 # reassign
A
# Indexing matrices
A <- matrix(1:10, 5, 2)
A[1, 2] # [row, col]
# Indexing matrices
A <- matrix(1:10, 5, 2)
A
A[1, 2] # [row, col]
A[1, ] # Entire first row
A[-1,] # All the rows excepts first one
A[, 2] # Entire 2nd col
A[ ,2] # Entire 2nd col
A[nrow(A), ] # entire last row. Otherway with ncol() for the column
A[1:4, 1:2] # 4 rows and 2 columns
A[1:nrow(A), 1:ncol(A)] # Entire matrix
A[c(1, 3), ] # Entire first and third rows
A[1, 2] = 9 # reassign
A
A = A[-nrow(A), ] #Last col is deleted. Since negative is for exclusion, rows or cols can be deleted this way.
A
nrow(A)
ncol(A)
dim(A)
# With matrix and seq
M2 <- matrix(1:12, 4, 3)
M2
storage.mode(num)
num = 45
typeof(num)
mode(num)
storage.mode(num)
class(name)
class(num) # Classification of objects, i.e. 'numeric' or 'character'
# Variables
name = "Jonny"
typeof(name)
is.character(name)
class(name)
num = 45
typeof(num)
mode(num) # Classification of objects, i.e. 'numeric' or 'character'
# Variables
num = 45
typeof(num)
mode(num) # Classification of objects, i.e. 'numeric' or 'character'
storage.mode(num) # gives the
class(num)
num2 = 4.5
class(num2)
mode(2.34)
x = as.integer(10)
typeof(x)
x = 10L
typeof(x)
x2 <- 5
1:x2 - 1 # Each element is subtracted by 1.
x <- rnorm(10)
x
x <-rnorm(10, mean = 20, sd=2)
x
# cbind and rbind in dataframe
rbind(students, data.frame(id=104, name='Joshua', score=89.35))
source('~/Documents/Code/MyProgramming/R/learning_R/dataframes.R')
# cbind and rbind in dataframe
rbind(students, data.frame(id=104, name='Joshua', score=89.35))
# Edit() function. edit(dataframe, factor, logical)
a <- edit(students)
# Edit() function. edit(dataframe, factor, logical)
a <- edit(students)
a
# Edit() function. edit(dataframe, factor, logical)
edit(students)
# Edit() function. edit(dataframe, factor, logical)
edit(students)
source('~/Documents/Code/MyProgramming/R/learning_R/dataframes.R')
# Edit() function. edit(dataframe, factor, logical)
edit(students)
# Edit() function. edit(dataframe, factor, logical)
view(students)
# Edit() function. edit(dataframe, factor, logical)
View(students)
# Edit() function. edit(dataframe, factor, logical)
edit(students)
# Edit() function. edit(dataframe, factor, logical)
Edit(students)
# Edit() function. edit(dataframe, factor, logical)
edit(students)
# Edit() function. edit(dataframe, factor, logical)
edit(students)
# Edit() function. edit(dataframe, factor, logical)
edit(students) # This opens the dataframe into an external R data editor, XQuartz in MacOS.
# Edit() function. edit(dataframe, factor, logical)
edit(students) # This opens the dataframe into an external R data editor, XQuartz in MacOS.
# With vectorized custamization and dummy data.
# Create the input vectors.
colors = c("green","orange","brown")
months <- c("Mar","Apr","May","Jun","Jul")
regions <- c("UK","USA","India")
# Create the matrix of the values.
revenue <- matrix(c(2,9,3,11,9,4,8,7,3,12,5,2,8,10,11), nrow = 3, ncol = 5, byrow = TRUE)
# chart file a name
png(file = "stacked_barchart.png")
# Create the bar chart
barplot(revenue, main = "Total Annual Revenue of IBM",
names.arg = months,
xlab = "month",
ylab = "Revenue (Billion)",
col = colors)
# Adding legend to the chart
legend("topleft", regions, cex = 1, fill = colors) # cex is the size of the legend.
# Save the file
dev.off()
# Create the bar chart
barplot(revenue, main = "Total Annual Revenue of IBM",
names.arg = months,
xlab = "month",
ylab = "Revenue (Billion)",
col = colors)
# Adding legend to the chart
legend("topleft", regions, cex = 1, fill = colors) # cex is the size of the legend.
revenue
mode(num) # Classification of objects, i.e. 'numeric', 'character', or 'logical'
# Variables
num = 45
typeof(num)
mode(num) # Classification of objects, i.e. 'numeric', 'character', or 'logical'
storage.mode(num) # gives the
class(num) # Also the classfication of objects
setwd("~/Documents/Code/MyProgramming/R/learning_R")
# Stacked barplot. If the df is matrix, then it will create stacked bargraph
df2 <- read.csv('data/murdersmini.csv')
df2 <- data.matrix(d2)
df2 <- data.matrix(df2)
df2
# matrix can only have numeric values
df2 <- t(df2)
df2
barplot(df2)
# Stacked barplot. If the df is matrix, then it will create stacked bargraph
df2 <- read.csv('data/murdersmini.csv')
df2 <- mutate(df2, ppt=population/10000) # Population per ten thousand. Just for convenience.
#mutate function. Used to add columns (can be derived from exising) or change existing ones.
mutate(df, murder_to_pop_ratio=murders/population)
library(dplyr)
df <- read.csv('data/murders.csv')
df
#barplot function. argument is numberical vector
barplot(select(df,state,population)$population, # Selected state and population from df. Plotting vs. population
xlab='abb',
ylab='population',
main='States vs. Population',
names.arg = df$state, # names for each bar
col = 'brown',
border = 'blue')
# Stacked barplot. If the df is matrix, then it will create stacked bargraph
df2 <- read.csv('data/murdersmini.csv')
df2 <- mutate(df2, ppt=population/10000) # Population per ten thousand. Just for convenience.
df2 <- df2[c(1, 3, ppt)] # state, murder, and the new population measure.
df2 <- mutate(df2, ppt=population/10000) # Population per ten thousand. Just for convenience.
df2 <- df2[c(1, 3, 4)] # state, murder, and the new population measure.
df2 <- data.matrix(df2) # converting df2 to a matrix. State names are now numeric values, since
# matrix can only have numeric values
df2 <- t(df2)
# matrix can only have numeric values
df2 <- t(df2)
df2
# matrix can only have numeric values
df2 <- t(df2)
df2
barplot(df2)
barplot(df2, xlab = "States",
main = "Population Vs. Murders",
col = c('blue', 'red'),
)
# Stacked barplot. If the df is matrix, then it will create stacked bargraph
df2 <- read.csv('data/murdersmini.csv')
df2_mutated <- mutate(df2, ppt=population/10000) # Population per ten thousand. Just for convenience.
df2_chart_data <- df_mutated[c(1, 3, 4)] # state, murder, and the new population measure.
df2_chart_data <- df2_mutated[c(1, 3, 4)] # state, murder, and the new population measure.
df2_m <- data.matrix(df2_chart_data) # converting df2 to a matrix. State names are now numeric values, since
# matrix can only have numeric values
df2_trans <- t(df2_m)
# matrix can only have numeric values
df2_trans <- t(df2_m)
df2_m
# matrix can only have numeric values
df2_trans <- t(df2_m)
df2_m
barplot(df2_m, xlab = "States",
main = "Population Vs. Murders",
col = c('blue', 'red'),
names.arg = df2$states)
df2_m <- data.matrix(df2_chart_data) # converting df2 to a matrix. State names are now numeric values, since
# matrix can only have numeric values
df2_trans <- t(df2_m)
# matrix can only have numeric values
df2_trans <- t(df2_m)
df2_m
df2_m
# Stacked barplot. If the df is matrix, then it will create stacked bargraph
df2 <- read.csv('data/murdersmini.csv')
df2 <- mutate(df2, ppt=population/10000) # Population per ten thousand. Just for convenience.
df2 <- df2[c(1, 3, 4)] # state, murder, and the new population measure.
df2_matrix <- data.matrix(df2) # converting df2 to a matrix. State names are now numeric values, since
# matrix can only have numeric values
df2_trans <- t(df2_matrix)
df2_matrix
barplot(df2_m, xlab = "States",
main = "Population Vs. Murders",
col = c('blue', 'red'),
names.arg = df2$states)
df2_trans
barplot(df2_trans, xlab = "States",
main = "Population Vs. Murders",
col = c('blue', 'red'),
names.arg = df2$states)
barplot(df2_trans, xlab = "States",
main = "Population Vs. Murders",
col = c('blue', 'red'),
names.arg = df2$states) # df2 still has the names of the states
df2_trans
barplot(df2_trans, xlab = "States",
main = "Population Vs. Murders",
col = c('blue', 'red'),
names.arg = df2$states) # df2 still has the names of the states
barplot(df2_trans, xlab = "States",
main = "Population Vs. Murders",
col = c('blue', 'red'),
names.arg = df2$states) # df2 still has the names of the states
barplot(df2_trans, xlab = "States",
main = "Population Vs. Murders",
col = c('blue', 'red'),
names.arg = df2$state) # df2 still has the names of the states
legend("topleft", c("Population", "Murders"), fill = c("blue", 'red'))
legend("topright", c("Population", "Murders"), fill = c("blue", 'red'))
barplot(df2_trans, xlab = "States",
main = "Population Vs. Murders",
col = c('blue', 'red'),
names.arg = df2$state) # df2 still has the names of the states
legend("topright", c("Population", "Murders"), fill = c("blue", 'red'))
barplot(df2_trans, xlab = "States",
main = "Population Vs. Murders",
col = c('blue', 'red'),
names.arg = df2$state) # df2 still has the names of the states
legend("topleft", c("Population", "Murders"), fill = c("blue", 'red'))
library(dplyr)
df <- read.csv('data/GEStock.csv')
df <- select(df, Date, Price)
hist(df$Price)
hist(df$Price,
xlab = 'Stock Price',
main = 'Stocks Data',
col = 'orange',
border = 'green')
hist(df$Price,
xlab = 'Stock Price',
main = 'Stocks Data',
col = 'orange',
border = 'brown',
breaks = 20) # To specify the number of bins
df_sub <- select(df, Date, Price)
hist(df_sub$Price,
xlab = 'Stock Price',
main = 'Stocks Data',
col = 'orange',
border = 'brown',
breaks = 20) # To specify the number of bins
plot(df_sub$population, df_sub$murders)
df_sub <- select(df,state, population, murders)
df
df <- read.csv('data/murders.csv')
df
df_sub <- select(df,state, population, murders)
plot(df_sub$population,df_sub$murders)
plot(df_sub$population,df_sub$murders,
xlab = 'Population',
ylab = 'Murders',
main = 'Population vs. Murders',
col = 'red')
plot(df_sub$population,df_sub$murders,
xlab = 'Population',
ylab = 'Murders',
main = 'Population vs. Murders',
col = 'red',
pch = 20)
# Line graph
plot(df_sub$murders, type = 'l',
xlab = 'States',
ylab = 'Murders',
main = 'States vs Murders',
col = 'blue')
library(dplyr)
df <- read.csv('data/murders.csv')
boxplot(df_sub$murders ~ df_sub$region,
xlab = 'Region',
ylab = 'Murders',
main = 'Region vs. Murders',
col = 'red',
border = 'blue',
notch = TRUE) # grouping the number of murders according to region.
df_sub <- select(df, state, population, murders, region)
boxplot(df_sub$murders ~ df_sub$region,
xlab = 'Region',
ylab = 'Murders',
main = 'Region vs. Murders',
col = 'red',
border = 'blue',
notch = TRUE) # grouping the number of murders according to region.
boxplot(
df_sub$murders ~ df_sub$region,
# grouping the number of murders according to region.
xlab = 'Region',
ylab = 'Murders',
main = 'Region vs. Murders',
col = 'red',
border = 'blue',
)
boxplot(
df_sub$murders ~ df_sub$region,
# grouping the number of murders according to region.
xlab = 'Region',
ylab = 'Murders',
main = 'Region vs. Murders',
col = 'red',
border = 'blue',
notch = TRUE #
)
library(dplyr)
df <- read.csv('murdersmini.csv')
df <- read.csv('data/murdersmini.csv')
df_mut <- mutate(df, ppt=population/10000)
names(df_mut)
df <- read.csv('data/murdersmini.csv')
df <- mutate(df, ppt=population/10000)
names(df)
df <- df[c(1, 3, 4)]
barplot(df$ppt, xlab = 'States', ylab = 'Population',
main = 'States vs. Population',
col = 'blue',
names.arg = df$state)
barplot(df$murders, xlab = 'States', ylab = 'Murders',
main = 'States vs Murders',
col = 'blue',
names.arg = df$state)
par(mfrow=c(1, 2)) #Dividing the plot area 1 row and 2 col (2 areas in one row)
library(dplyr)
df <- read.csv('data/murdersmini.csv')
df <- mutate(df, ppt=population/10000)
names(df)
df <- df[c(1, 3, 4)]
barplot(df$ppt, xlab = 'States', ylab = 'Population',
main = 'States vs. Population',
col = 'blue',
names.arg = df$state)
barplot(df$murders, xlab = 'States', ylab = 'Murders',
main = 'States vs Murders',
col = 'blue',
names.arg = df$state)
par(mfrow=c(2, 2)) #Dividing the plot area 1 row and 2 col (2 areas in one row)
library(dplyr)
df <- read.csv('data/murdersmini.csv')
df <- mutate(df, ppt=population/10000)
names(df)
df <- df[c(1, 3, 4)]
barplot(df$ppt, xlab = 'States', ylab = 'Population',
main = 'States vs. Population',
col = 'blue',
names.arg = df$state)
barplot(df$murders, xlab = 'States', ylab = 'Murders',
main = 'States vs Murders',
col = 'blue',
names.arg = df$state)
plot(df$ppt, df$murders,
xlab = 'Population',
ylab = 'Murders',
main = 'Population vs Murders',
col = 'red',
pch = 10)
plot(df$ppt, df$murders,
xlab = 'Population',
ylab = 'Murders',
main = 'Population vs Murders',
col = 'red',
pch = 15)
plot(df$ppt, df$murders,
xlab = 'Population',
ylab = 'Murders',
main = 'Population vs Murders',
col = 'red',
pch = 30)
plot(df$ppt, df$murders,
xlab = 'Population',
ylab = 'Murders',
main = 'Population vs Murders',
col = 'red',
pch = 16)
par(mfrow=c(2, 2)) #Dividing the plot area into nrow and col
library(dplyr)
df <- read.csv('data/murdersmini.csv')
df <- mutate(df, ppt=population/10000)
names(df)
df <- df[c(1, 3, 4)]
barplot(df$ppt, xlab = 'States', ylab = 'Population',
main = 'States vs. Population',
col = 'blue',
names.arg = df$state)
barplot(df$murders, xlab = 'States', ylab = 'Murders',
main = 'States vs Murders',
col = 'blue',
names.arg = df$state)
plot(df$ppt, df$murders,
xlab = 'Population',
ylab = 'Murders',
main = 'Population vs Murders',
col = 'red',
pch = 16)
